use crate::{Operation, LogicOp, RelationOp, ArithmeticOp, Expression, UnaryOp, Member, Literal};
use std::rc::Rc;

grammar;

match {
    // Skip whitespace and comments
   r"\s*" => { },
   r"//[^\n\r]*[\n\r]*" => { },
} else {
   _
}

pub Expression: Expression = {
    <condition:ConditionalOr> "?" <left:ConditionalOr> ":" <right:Expression> => Expression::Ternary(condition.into(), left.into(), right.into()),
    ConditionalOr
};

Tier<Op,NextTier>: Expression = {
    <left:Tier<Op,NextTier>> <op:Op> <right:NextTier> => Expression::from_op(op, left.into(), right.into()),
    NextTier
};

ConditionalOr: Expression = Tier<LogicOr, ConditionalAnd>;
ConditionalAnd: Expression = Tier<LogicAnd, Relation>;
Relation: Expression = Tier<RelationOp, Addition>;
Addition: Expression = Tier<AdditionOp, Multiplication>;
Multiplication: Expression = Tier<MultiplicationOp, Unary>;

Unary: Expression = {
    <op:UnaryOp> <expr:Member> => Expression::Unary(op, expr.into()),
    Member
};

Member: Expression = {
    <left:Member> "." <identifier:Ident> => Expression::Member(left.into(), Member::Attribute(identifier.into()).into()).into(),
    <left:Member> "." <identifier:Ident> "(" <arguments:CommaSeparated<Expression>> ")" => {
            let inner = Expression::Member(left.into(), Member::Attribute(identifier.into()).into()).into();
            Expression::Member(inner, Member::FunctionCall(arguments).into()).into()
    },
    <left:Member> "[" <expression:Expression> "]" => Expression::Member(left.into(), Member::Index(expression.into()).into()).into(),
    Primary,
}

Primary: Expression = {
    "."? <Ident> => Expression::Ident(<>.into()),
    "."? <identifier:Ident> "(" <arguments:CommaSeparated<Expression>> ")" => {
            let inner = Expression::Ident(identifier.into()).into();
            Expression::Member(inner, Member::FunctionCall(arguments).into()).into()
    },
    "(" <Expression> ")",
    "[" <members:CommaSeparated<Expression>> "]" => Expression::List(<>).into(),
    "{" <fields:CommaSeparated<MapInits>> "}" => Expression::Map(<>).into(),
    "."? <ident:Ident+> "{" <fields:CommaSeparated<FieldInits>> "}" => Expression::Struct(ident,fields),
    Literal => Expression::Literal(<>)
}

FieldInits: (Rc<String>, Expression) = {
    <Ident> ":" <Expression>
}

MapInits: (Expression, Expression) = {
    <Expression> ":" <Expression>
}

CommaSeparated<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

LogicOr: Operation = {
  "||" => Operation::Logic(LogicOp::Or)
};
LogicAnd: Operation = {
  "&&" => Operation::Logic(LogicOp::And)
};
RelationOp: Operation = {
    "<" => Operation::Relation(RelationOp::LessThan),
    "<=" => Operation::Relation(RelationOp::LessThanEq),
    ">" => Operation::Relation(RelationOp::GreaterThan),
    ">=" => Operation::Relation(RelationOp::GreaterThanEq),
    "==" => Operation::Relation(RelationOp::Equals),
    "!=" => Operation::Relation(RelationOp::NotEquals),
    "in" => Operation::Relation(RelationOp::In)
}
AdditionOp: Operation = {
    "+" => Operation::Arithmetic(ArithmeticOp::Add),
    "-" => Operation::Arithmetic(ArithmeticOp::Subtract),
};
MultiplicationOp: Operation = {
    "*" => Operation::Arithmetic(ArithmeticOp::Multiply),
    "/" => Operation::Arithmetic(ArithmeticOp::Divide),
    "%" => Operation::Arithmetic(ArithmeticOp::Modulus),
};
UnaryOp: UnaryOp = {
    <v:"!"+> => if v.len() % 2 == 0 { UnaryOp::DoubleNot } else { UnaryOp::Not },
    <v:"-"+> => if v.len() % 2 == 0 { UnaryOp::DoubleMinus } else { UnaryOp::Minus },
};

Literal: Literal = {
    // Integer literals. Annoying to parse :/
    r"-?[0-9]+" => Literal::Int(<>.parse().unwrap()),
    r"-?0[xX]([0-9a-fA-F]+)" => Literal::Int(i64::from_str_radix(<>, 16).unwrap()),
    r"-?[0-9]+ [uU]" => Literal::UInt(<>.parse().unwrap()),
    r"-?0[xX]([0-9a-fA-F]+) [uU]" => Literal::UInt(u64::from_str_radix(<>, 16).unwrap()),

    // Float with decimals and optional exponent
    r"([-+]?[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?)" => Literal::Double(<>.parse().unwrap()),
    // Float with no decimals and required exponent
    r"[-+]?[0-9]+[eE][-+]?[0-9]+" => Literal::Double(<>.parse().unwrap()),

    // Double quoted string
    r#""(\\.|[^"\n])*""# => Literal::String(<>.to_string().into()),
    r#""""(\\.|[^"{3}])*""""# => Literal::String(<>.to_string().into()),

    // Single quoted string
    r#"'(\\.|[^'\n])*'"# => Literal::String(<>.to_string().into()),
    r#"'''(\\.|[^'{3}])*'''"# => Literal::String(<>.to_string().into()),

    // Double quoted bytes
    r#"[bB]"(\\.|[^"\n])*""# => Literal::Bytes(Vec::from(<>.as_bytes()).into()),
    r#"[bB]"""(\\.|[^"{3}])*""""# => Literal::Bytes(Vec::from(<>.as_bytes()).into()),

    // Single quoted bytes
    r#"[bB]'(\\.|[^'\n])*'"# => Literal::Bytes(Vec::from(<>.as_bytes()).into()),
    r#"[bB]'''(\\.|[^'{3}])*'''"# => Literal::Bytes(Vec::from(<>.as_bytes()).into()),

    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "null" => Literal::Null,
};

Ident: Rc<String> = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string().into()
}
